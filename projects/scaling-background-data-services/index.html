<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Scaling Custom Indexing Data Services | ameya.karkal</title>
<meta name="keywords" content="">
<meta name="description" content="I was working as a full time Senior Software Developer in a project that indexed data generated by multiple data sources. This legacy system had outgrown from its initial single responsibility of &ldquo;managing indicies in ElasticSearch&rdquo; to handle more things were vague but still could be bucketed in the managing indicies bucket
The product that used this service had a requirement for a data source that could handle analytical query workload.">
<meta name="author" content="">
<link rel="canonical" href="https://ameyakarkal.github.io/projects/scaling-background-data-services/">
<meta name="google-site-verification" content="c1Y4Uy69lFhrg0JTlUtN_HbEpAR4g6YjUjDNDztmfMA">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://ameyakarkal.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://ameyakarkal.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://ameyakarkal.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://ameyakarkal.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://ameyakarkal.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-8TM2N649W7"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag() { dataLayer.push(arguments); }
    gtag('js', new Date());

    gtag('config', 'G-8TM2N649W7');
</script>
<meta property="og:title" content="Scaling Custom Indexing Data Services" />
<meta property="og:description" content="I was working as a full time Senior Software Developer in a project that indexed data generated by multiple data sources. This legacy system had outgrown from its initial single responsibility of &ldquo;managing indicies in ElasticSearch&rdquo; to handle more things were vague but still could be bucketed in the managing indicies bucket
The product that used this service had a requirement for a data source that could handle analytical query workload." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://ameyakarkal.github.io/projects/scaling-background-data-services/" />
<meta property="og:image" content="https://ameyakarkal.github.io/images/projects/scaling-background-data-services.jpg" /><meta property="article:section" content="projects" />
<meta property="article:published_time" content="2020-03-01T00:00:00-05:00" />
<meta property="article:modified_time" content="2020-03-01T00:00:00-05:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://ameyakarkal.github.io/images/projects/scaling-background-data-services.jpg" />
<meta name="twitter:title" content="Scaling Custom Indexing Data Services"/>
<meta name="twitter:description" content="I was working as a full time Senior Software Developer in a project that indexed data generated by multiple data sources. This legacy system had outgrown from its initial single responsibility of &ldquo;managing indicies in ElasticSearch&rdquo; to handle more things were vague but still could be bucketed in the managing indicies bucket
The product that used this service had a requirement for a data source that could handle analytical query workload."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Projects",
      "item": "https://ameyakarkal.github.io/projects/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Scaling Custom Indexing Data Services",
      "item": "https://ameyakarkal.github.io/projects/scaling-background-data-services/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Scaling Custom Indexing Data Services",
  "name": "Scaling Custom Indexing Data Services",
  "description": "I was working as a full time Senior Software Developer in a project that indexed data generated by multiple data sources. This legacy system had outgrown from its initial single responsibility of \u0026ldquo;managing indicies in ElasticSearch\u0026rdquo; to handle more things were vague but still could be bucketed in the managing indicies bucket\nThe product that used this service had a requirement for a data source that could handle analytical query workload.",
  "keywords": [
    
  ],
  "articleBody": "I was working as a full time Senior Software Developer in a project that indexed data generated by multiple data sources. This legacy system had outgrown from its initial single responsibility of “managing indicies in ElasticSearch” to handle more things were vague but still could be bucketed in the managing indicies bucket\nThe product that used this service had a requirement for a data source that could handle analytical query workload. This was 2018, and with the skills and experience available at hand Elasticsearch was chosen the data store. As this was a multi-tenant service it was decided to have an index per client and a metadata index to hold a mapping between tenant-id and index\nstack used: azure-functions azure-storage-queue azure-storage\nWhat were the challenges ? Upstream systems would clean/join/transform multiple datasources and produce an intermediate result which was stored at an azure storage account on a nighthly cadance. Each such “upstream job” had an id which would determine the location of the files. The indexer would then index these files as part of its “job”.\nThe indexer had the following roles which it performed most of the times\nfigure out when the current indexing job completed and trigger upstream job (to a different service which would generate the intermediate result) poll the upstream system to check on when the next job could be started index the multiple files (usually ~100GBs per job) manage life cycle of intermediate results from nightly jobs There were multiple challenges with the scope of the service and how the tasks were implemented\nEven though the indexes were multi tenant, the process was NOT. this was a huge red flag as it was possible that bad data / issues from one tenant could technically affect other clients General debugging was too difficult and performing root cause analysis would take couple of days which would affect the Quality of Service The service was not horizontally scalable. It was a node based process that spawned child processes to handle the files. There was a limit on the number of processes that could be spawned which was capped to the number of processors available on the server where this was deployed. engineering bits scaling horizontally I moved to a manager-worker pattern where one instance of the service act as a manager and would generate azure-storage-queue tickets for each of the files that needed to be processed. The same service could also be deployed as a worker instance, which would listent to tickets and process them.\ntransparency This helped to make the workload on the service more transparent as we could track metrics on the azure-storage-queue.\nI deployed this service in a one-to-many manager worker configuration. This helped improved the performance of the system by a factor of N (n = number of workers). There was an non trival overhead of managing sending the tickets and polling (and retrying) for completeness of a worker Task, however it was managable for the performance boost we were getting.\ntenant based workload This architecture helped upstream jobs to generate intermediate results per tenant. This gave us the power to process an individual tenant whenever it was required and also helped isolating failures per tenant.\nresponsibility We were able to carve out a responsibility per thread in the manager service. We moved non trivial but non core responsibilities like storage account management out of this service altogether using the management services provided by azure storage account out of the box (you can setup life cycle management rules on azure storage account that move service level tier or delete blobs based on configuration)\nlearnings refactor \u003e rewrite scope the responsibilities of your services. You won’t get this right the first or second time, however measuring the right metrics on your service and applying the feedback is crucial. ",
  "wordCount" : "633",
  "inLanguage": "en",
  "image":"https://ameyakarkal.github.io/images/projects/scaling-background-data-services.jpg","datePublished": "2020-03-01T00:00:00-05:00",
  "dateModified": "2020-03-01T00:00:00-05:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://ameyakarkal.github.io/projects/scaling-background-data-services/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ameya.karkal",
    "logo": {
      "@type": "ImageObject",
      "url": "https://ameyakarkal.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://ameyakarkal.github.io" accesskey="h" title="ameya.karkal (Alt + H)">ameya.karkal</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://ameyakarkal.github.io">Home</a>&nbsp;»&nbsp;<a href="https://ameyakarkal.github.io/projects/">Projects</a></div>
    <h1 class="post-title">
      Scaling Custom Indexing Data Services
    </h1>
    <div class="post-meta"><span title='2020-03-01 00:00:00 -0500 EST'>March 1, 2020</span>&nbsp;·&nbsp;3 min

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://ameyakarkal.github.io/images/projects/scaling-background-data-services.jpg" alt="">
        
</figure>
  <div class="post-content"><p>I was working as a full time Senior Software Developer in a project that indexed data generated by multiple data sources. This legacy system had outgrown from its initial single responsibility of &ldquo;managing indicies in ElasticSearch&rdquo; to handle more things were vague but still could be bucketed in the <em>managing indicies</em> bucket</p>
<p>The product that used this service had a requirement for a data source that could handle analytical query workload. This was 2018, and with the skills and experience available at hand Elasticsearch was chosen the data store. As this was a multi-tenant service it was decided to have an index per client and a metadata index to hold a mapping between tenant-id and index</p>
<p>stack used: <code>azure-functions</code> <code>azure-storage-queue</code> <code>azure-storage</code></p>
<h2 id="what-were-the-challenges-">What were the challenges ?<a hidden class="anchor" aria-hidden="true" href="#what-were-the-challenges-">#</a></h2>
<p>Upstream systems would clean/join/transform multiple datasources and produce an intermediate result which was stored at an azure storage account on a nighthly cadance. Each such &ldquo;upstream job&rdquo; had an <code>id</code> which would determine the location of the files. The indexer would then index these files as part of its &ldquo;job&rdquo;.</p>
<p>The indexer had the following roles which it performed <em>most</em> of the times</p>
<ul>
<li>figure out when the current indexing job completed and trigger upstream job (to a different service which would generate the intermediate result)</li>
<li>poll the upstream system to check on when the next job could be started</li>
<li>index the multiple files (usually ~100GBs per job)</li>
<li>manage life cycle of intermediate results from nightly jobs</li>
</ul>
<p>There were multiple challenges with the scope of the service and how the tasks were implemented</p>
<ul>
<li>Even though the indexes were multi tenant, the process was NOT. this was a huge red flag as it was possible that bad data / issues from one tenant could technically affect other clients</li>
<li>General debugging was too difficult and performing root cause analysis would take couple of days which would affect the Quality of Service</li>
<li>The service was not horizontally scalable. It was a node based process that spawned child processes to handle the files. There was a limit on the number of processes that could be spawned which was capped to the number of processors available on the server where this was deployed.</li>
</ul>
<h2 id="engineering-bits">engineering bits<a hidden class="anchor" aria-hidden="true" href="#engineering-bits">#</a></h2>
<h3 id="scaling-horizontally">scaling horizontally<a hidden class="anchor" aria-hidden="true" href="#scaling-horizontally">#</a></h3>
<p>I moved to a manager-worker pattern where one instance of the service act as a manager and would generate azure-storage-queue tickets for each of the files that needed to be processed. The same service could also be deployed as a worker instance, which would listent to tickets and process them.</p>
<h3 id="transparency">transparency<a hidden class="anchor" aria-hidden="true" href="#transparency">#</a></h3>
<p>This helped to make the workload on the service more transparent as we could track metrics on the azure-storage-queue.</p>
<p>I deployed this service in a one-to-many manager worker configuration. This helped improved the performance of the system by a factor of N (n = number of workers). There was an non trival overhead of managing sending the tickets and polling (and retrying) for completeness of a worker <code>Task</code>, however it was managable for the performance boost we were getting.</p>
<h3 id="tenant-based-workload">tenant based workload<a hidden class="anchor" aria-hidden="true" href="#tenant-based-workload">#</a></h3>
<p>This architecture helped upstream jobs to generate intermediate results per tenant. This gave us the power to process  an  individual tenant whenever it was required and also helped isolating failures per tenant.</p>
<h4 id="responsibility">responsibility<a hidden class="anchor" aria-hidden="true" href="#responsibility">#</a></h4>
<p>We were able to carve out a responsibility per thread in the manager service. We moved non trivial but non core responsibilities like storage account management out of this service altogether using the management services provided by azure storage account out of the box (you can setup life cycle management rules on azure storage account that move service level tier or delete blobs based on configuration)</p>
<h2 id="learnings">learnings<a hidden class="anchor" aria-hidden="true" href="#learnings">#</a></h2>
<ul>
<li>refactor &gt; rewrite</li>
<li>scope the responsibilities of your services. You won&rsquo;t get this right the first or second time, however measuring the right metrics on your service and applying the feedback is crucial.</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://ameyakarkal.github.io">ameya.karkal</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
